#pragma config(Motor,  port1,           dtBR,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           clawMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           SpinnyLeft,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port4,           dtFR,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           dtFL,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           SpinnyRight,   tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           mgR,           tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           mgL,           tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           LiftArm,       tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port10,          dtBL,          tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// mg = mobile goal
// dt = drive train

//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma platform(VEX2)
#pragma competitionControl(Competition) //Competition Control Settings
#pragma autonomousDuration(15)
#pragma userControlDuration(105)
/***********************************************************************************************
Team: RoboWarriors	98872 R
************************************************************************************************/
//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/************************************************************************************************/
/*  Function Prototypes   								                                                      */
/************************************************************************************************/
void MoveArm(int power);
void ArcReverseRobot();
void StopArm(int power);
void MoveArm2(int power);
void StopArm2(int power);
void MoveRobot(int power);
void PivotRobot(int power);

//int liftArmPowerUp = 100;
//int liftArmPowerDown = -80;
int liftPower = 100;
int spinnyUpPower = 50;
int spinnyDownPower = 80;
bool isArmUp = false;
bool intakeIsPicking = false;
int clawReading = 0;
//int liftArmPowerHold = 0; //10
int clawPower = -100;
//int clawHoldPower = -10;
int X1 = 0, Y3 = 0, threshold = 35	;
//int X2 = 0, Y4 = 0;

int mobileConePower = 100;
void MoveMobileArm(int power);

// Cone management
void pickupCone();

void autonStationary();

/************************************************************************************************/
/*  pre_auton : Setup before Auton program   	                        */
/************************************************************************************************/
void pre_auton()
{
}

/************************************************************************************************/
/*  autonomous : Called by competition switch											    	                        */
/************************************************************************************************/
task autonomous()
{

	autonStationary(); return;

	MoveMobileArm(-mobileConePower);
	wait1Msec(100); //1000

	// setup one cone width from wall.
	MoveRobot(60); // go to mobile goal
	wait1Msec(1100);
	MoveRobot(0);

	MoveRobot(100); // go to mobile goal
	wait1Msec(800); //1000
	MoveRobot(0);
	wait1Msec(500);

	MoveMobileArm(mobileConePower);

	//rcReverseRobot(); // go back
	MoveRobot(-60);
	wait1Msec(1800);
	MoveRobot(0);

	wait1Msec(100); //1000

	PivotRobot(50); // turn
	wait1Msec(1900);
	MoveRobot(0);

	MoveRobot(100);
	wait1Msec(900);
	MoveRobot(0);

	MoveMobileArm(-mobileConePower);
	wait1Msec(500); //1000

	MoveRobot(-100);// go back
	wait1Msec(800);
	MoveRobot(0);

	return;

	MoveMobileArm(mobileConePower);

	MoveRobot(-40); // go back
	wait1Msec(1000);
	MoveRobot(0);

	wait1Msec(500);

	MoveMobileArm(-mobileConePower);
	wait1Msec(1000);

	MoveRobot(60); // ensure it is in!!!
	wait1Msec(1000);
	MoveRobot(0);


}

/************************************************************************************************/
/*  autonStationary - for defense
/************************************************************************************************/
void autonStationary()
{

	MoveRobot(60);
	wait1Msec(300);
	MoveRobot(0);

	// lift arm
	MoveArm(liftPower);
	wait1Msec(500);
	MoveArm(0);
	// bring spinny to goal
	MoveArm2(-spinnyDownPower);
	wait1Msec(1050);//2100
	MoveArm2(0);
	// release from claw
	motor[clawMotor] = -80;
	wait1Msec(500);
	motor[clawMotor] = 0;
	// bring spinny to goal
	MoveArm2(spinnyDownPower);
	wait1Msec(1000);
	MoveArm2(0);
	// back up a bit
	MoveRobot(-60);
	wait1Msec(100);
	MoveRobot(0);
	//turn right
	PivotRobot(60);
	wait1Msec(450); //550
	MoveRobot(0);
	// bring arm down
	MoveMobileArm(mobileConePower);
	// bring down arm
	MoveArm(-liftPower);
	wait1Msec(400);
	MoveArm(0);
	// go forward beyond moGo
	MoveRobot(60);
	wait1Msec(800);
	MoveRobot(0);
	//turn left
	PivotRobot(-60);
	wait1Msec(450);
	MoveRobot(0);
	//go straight for defence
	MoveRobot(100);
	wait1Msec(1500);
	MoveRobot(0);

}

/************************************************************************************************/
/*  usercontrol : Driver control             											    	                        */
/************************************************************************************************/
task usercontrol()
{
	while (true)
	{
		//Create "deadzone" for Y1/Ch3
		if(abs(vexRT[Ch1]) > threshold) // ch4 if one joystick driving (left)
			Y3 = vexRT[Ch1];
		else
			Y3 = 0;
		//Create "deadzone" for X2/Ch1
		if(abs(vexRT[Ch3]) > threshold)
			X1 = vexRT[Ch3];
		else
			X1 = 0;

		//Remote Control Commands
		motor[dtFR]	= Y3 - X1;//Y3 - X1;
		motor[dtBR]	= Y3 - X1;//Y3 - X1;
		motor[dtFL]	= Y3 + X1;//Y3 + X1;
		motor[dtBL]	= Y3 + X1;//Y3 + X1;


		// MoGo
		if (vexRT[Btn6U]==1)
		{
			MoveMobileArm(-mobileConePower); // neg power goes down
		}
		else if (vexRT[Btn6D]==1)
		{
			MoveMobileArm(mobileConePower); // pos power goes up
		}
		// Arm ===============================================
		if (vexRT[Btn5D]==1)
		{
			MoveArm(-liftPower);
			isArmUp = true;
		}
		else if (vexRT[Btn5U]==1)
		{
			MoveArm(liftPower); // -100 prev dropcone
			isArmUp = false;
		}
		else
		{
			StopArm(0);
		}
		//Spinny ===============================================
		if (vexRT[Btn8D]==1)
		{
			//if (isArmUp)
			//{
			//	MoveArm2(-spinnyDownPower*.5);
			//}
			//else
			//{
			MoveArm2(-spinnyDownPower);
			//}
		}
		else if (vexRT[Btn8U]==1)
		{
			MoveArm2(spinnyUpPower);
		}
		else
		{
			StopArm2(0);
		}
		//writeDebugStreamLine("isArmUp =%i", isArmUp);
		// Pickup cone  ====================================================
		if (vexRT[Btn8R]==1)
		{
			pickupCone();
		}

		// intake  ===============================================>
		//		motor[clawMotor] = 0;
		clawReading = abs(vexRT[Ch2]);
		writeDebugStreamLine("Read value =%i", clawReading);
		if (clawReading > threshold)
		{
			motor[clawMotor] = clawReading;
			} else {
			if (vexRT[Btn8L]==1)

			motor[clawMotor] = -80;
			else
				motor[clawMotor] = 10;

		}
	}
}

/************************************************************************************************/
/*  MobileArmForward                                         						    	                        */
/************************************************************************************************/
void MoveMobileArm(int power)
{
	motor[mgL] = power; // all location specifications dont mean anything
	motor[mgR] = power; // neg power = down &&& pos power = up
	wait1Msec(550);
	motor[mgL] = 0;
	motor[mgR] = 0;

}


/************************************************************************************************/
/*  MoveArm                                         						    	                        */
/************************************************************************************************/
void MoveArm(int power)
{
	motor[LiftArm] = power;
}

/************************************************************************************************/
/*  StopArm                                         						    	                        */
/************************************************************************************************/
void StopArm(int power)
{
	MoveArm(power);
}

/************************************************************************************************/
/*  MoveArm2                                         						    	                        */
/************************************************************************************************/
void MoveArm2(int power)
{
	motor[SpinnyLeft] = power;
	motor[SpinnyRight] = power;
}

/************************************************************************************************/
/*  StopArm2                                         						    	                        */
/************************************************************************************************/
void StopArm2(int power)
{
	MoveArm2(power);
}

/************************************************************************************************/
/*  Move robot                                         						    	                        */
/************************************************************************************************/
void MoveRobot(int power)
{
	motor[dtFR]	= -power;
	motor[dtBR]	= -power;
	motor[dtFL]	=  power;
	motor[dtBL]	=  power;
}

/************************************************************************************************/
/*  Move robot in an arc                                        						    	                        */
/************************************************************************************************/
void ArcReverseRobot()
{
	motor[dtFR]	= -40; //power + 15;
	motor[dtBR]	= -60; //power;
	motor[dtFL]	= -60; //power;
	motor[dtBL]	= -40; //power + 15;
}

/************************************************************************************************/
/*  Pivot robot                                         						    	                        */
/************************************************************************************************/
void PivotRobot(int power)
{
	motor[dtFR]	= power;
	motor[dtBR]	= power;
	motor[dtFL]	= power;
	motor[dtBL]	= power;
}

/************************************************************************************************/
/*  pickupCone
/*	Assumption:
/*					1. Robot is in position to pickup.
/************************************************************************************************/
void pickupCone() {
	// bring spinny to goal
	MoveArm2(-spinnyDownPower);
	wait1Msec(500);
	MoveArm2(0);
	//wait1Msec(1000); // wait to steady spinny
	// release from claw
	motor[clawMotor] = 80;
	wait1Msec(500);
	motor[clawMotor] = 10;
	// bring spinny to goal
	MoveArm2(spinnyDownPower);
	wait1Msec(800);
	MoveArm2(0);
	// make sure intake has power
	intakeIsPicking = true;
}
